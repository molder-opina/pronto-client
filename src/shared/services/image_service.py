"""Service for managing product images."""

from __future__ import annotations

import os
import uuid
from pathlib import Path

from werkzeug.datastructures import FileStorage
from werkzeug.utils import secure_filename

from shared.config import load_config
from shared.supabase.storage import SupabaseStorage, resolve_bucket


class ImageService:
    """Service for handling image uploads and management."""

    ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "webp", "gif"}
    MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB

    # Default paths (can be overridden at runtime by applications)
    _BASE_DIR = Path(__file__).resolve().parents[3]  # /.../build
    _STATIC_ROOT = _BASE_DIR / "static_content" / "assets"
    UPLOAD_FOLDER = os.getenv("STATIC_ASSETS_ROOT", str(_STATIC_ROOT))
    RESTAURANT_SLUG = os.getenv("RESTAURANT_SLUG", "cafeteria-test")
    SUPABASE_STORAGE_ENABLED = os.getenv("SUPABASE_STORAGE_ENABLED", "false").strip().lower() in {
        "1",
        "true",
        "yes",
        "on",
    }

    @staticmethod
    def allowed_file(filename: str) -> bool:
        """Check if file extension is allowed."""
        return (
            "." in filename
            and filename.rsplit(".", 1)[1].lower() in ImageService.ALLOWED_EXTENSIONS
        )

    @staticmethod
    def validate_image(file: FileStorage) -> tuple[bool, str | None]:
        """
        Validate uploaded image file.

        Returns:
            (is_valid, error_message)
        """
        if not file:
            return False, "No se proporcionó ningún archivo"

        if file.filename == "":
            return False, "Nombre de archivo vacío"

        if not ImageService.allowed_file(file.filename):
            return False, f"Formato no permitido. Use: {', '.join(ImageService.ALLOWED_EXTENSIONS)}"

        # Check file size (if available)
        if hasattr(file, "content_length") and file.content_length:
            if file.content_length > ImageService.MAX_FILE_SIZE:
                return False, "Archivo demasiado grande. Máximo: 5MB"

        return True, None

    @staticmethod
    def save_uploaded_image(
        file: FileStorage, category: str = "menu", restaurant_slug: str | None = None
    ) -> dict[str, str]:
        """
        Save uploaded image to static content folder.

        Args:
            file: The uploaded file
            category: Category folder (menu, branding, icons)
            restaurant_slug: Restaurant identifier

        Returns:
            Dict with path, url, filename

        Raises:
            ValueError: If validation fails
        """
        # Validate
        is_valid, error = ImageService.validate_image(file)
        if not is_valid:
            raise ValueError(error)

        # Get restaurant slug
        slug = restaurant_slug or ImageService.RESTAURANT_SLUG

        # Generate unique filename
        original_filename = secure_filename(file.filename)
        extension = original_filename.rsplit(".", 1)[1].lower()
        unique_filename = f"{uuid.uuid4().hex}.{extension}"

        if ImageService.SUPABASE_STORAGE_ENABLED and SupabaseStorage.is_available():
            config = load_config(os.getenv("APP_NAME", "pronto"))
            bucket = resolve_bucket(category, config)
            storage_path = f"{slug}/{category}/{unique_filename}"
            content = file.read()
            SupabaseStorage.upload_bytes(bucket, storage_path, content, file.mimetype)
            return {
                "filename": unique_filename,
                "original_filename": original_filename,
                "path": storage_path,
                "url": SupabaseStorage.get_public_url(bucket, storage_path),
                "bucket": bucket,
                "category": category,
                "size": len(content),
            }

        # Build paths (local filesystem fallback)
        upload_folder = Path(ImageService.UPLOAD_FOLDER)
        category_folder = upload_folder / slug / category
        category_folder.mkdir(parents=True, exist_ok=True)

        file_path = category_folder / unique_filename

        # Save file
        file.save(str(file_path))

        # Build URL path (relative to static server)
        url_path = f"/assets/{slug}/{category}/{unique_filename}"

        return {
            "filename": unique_filename,
            "original_filename": original_filename,
            "path": str(file_path),
            "url": url_path,
            "category": category,
            "size": file_path.stat().st_size if file_path.exists() else 0,
        }

    @staticmethod
    def save_raw_image(
        content: bytes,
        original_filename: str,
        category: str = "menu",
        restaurant_slug: str | None = None,
    ) -> dict[str, str]:
        """
        Persist an image already available in memory (e.g., generated by AI).
        """
        if not content:
            raise ValueError("La imagen recibida está vacía")

        slug = restaurant_slug or ImageService.RESTAURANT_SLUG

        extension = "png"
        if original_filename and "." in original_filename:
            ext_candidate = original_filename.rsplit(".", 1)[1].lower()
            if ext_candidate in ImageService.ALLOWED_EXTENSIONS:
                extension = ext_candidate

        unique_filename = f"{uuid.uuid4().hex}.{extension}"
        if ImageService.SUPABASE_STORAGE_ENABLED and SupabaseStorage.is_available():
            config = load_config(os.getenv("APP_NAME", "pronto"))
            bucket = resolve_bucket(category, config)
            storage_path = f"{slug}/{category}/{unique_filename}"
            SupabaseStorage.upload_bytes(bucket, storage_path, content, "image/png")
            return {
                "filename": unique_filename,
                "original_filename": original_filename or unique_filename,
                "path": storage_path,
                "url": SupabaseStorage.get_public_url(bucket, storage_path),
                "bucket": bucket,
                "category": category,
                "size": len(content),
            }

        upload_folder = Path(ImageService.UPLOAD_FOLDER)
        category_folder = upload_folder / slug / category
        category_folder.mkdir(parents=True, exist_ok=True)

        file_path = category_folder / unique_filename
        file_path.write_bytes(content)

        return {
            "filename": unique_filename,
            "original_filename": original_filename or unique_filename,
            "path": str(file_path),
            "url": f"/assets/{slug}/{category}/{unique_filename}",
            "category": category,
            "size": file_path.stat().st_size if file_path.exists() else 0,
        }

    @staticmethod
    def list_images(
        category: str = "menu", restaurant_slug: str | None = None
    ) -> list[dict[str, str]]:
        """
        List all images in a category.

        Args:
            category: Category folder (menu, branding, icons)
            restaurant_slug: Restaurant identifier

        Returns:
            List of image info dicts
        """
        slug = restaurant_slug or ImageService.RESTAURANT_SLUG
        if ImageService.SUPABASE_STORAGE_ENABLED and SupabaseStorage.is_available():
            config = load_config(os.getenv("APP_NAME", "pronto"))
            bucket = resolve_bucket(category, config)
            prefix = f"{slug}/{category}"
            files = SupabaseStorage.list_files(bucket, prefix)
            images = []
            for entry in files:
                name = entry.get("name") or entry.get("path") or entry.get("id")
                if not name or not ImageService.allowed_file(name):
                    continue
                storage_path = f"{prefix}/{name}"
                metadata = entry.get("metadata") or {}
                images.append(
                    {
                        "filename": name,
                        "url": SupabaseStorage.get_public_url(bucket, storage_path),
                        "path": storage_path,
                        "bucket": bucket,
                        "category": category,
                        "size": metadata.get("size", 0),
                        "modified": entry.get("updated_at") or entry.get("created_at"),
                    }
                )
            images.sort(key=lambda x: x.get("modified") or "", reverse=True)
            return images

        upload_folder = Path(ImageService.UPLOAD_FOLDER)
        category_folder = upload_folder / slug / category

        if not category_folder.exists():
            return []

        images = []
        for file_path in category_folder.iterdir():
            if file_path.is_file() and ImageService.allowed_file(file_path.name):
                images.append(
                    {
                        "filename": file_path.name,
                        "url": f"/assets/{slug}/{category}/{file_path.name}",
                        "path": str(file_path),
                        "category": category,
                        "size": file_path.stat().st_size,
                        "modified": file_path.stat().st_mtime,
                    }
                )

        # Sort by modification time (newest first)
        images.sort(key=lambda x: x["modified"], reverse=True)

        return images

    @staticmethod
    def delete_image(
        filename: str, category: str = "menu", restaurant_slug: str | None = None
    ) -> bool:
        """
        Delete an image file.

        Args:
            filename: The filename to delete
            category: Category folder
            restaurant_slug: Restaurant identifier

        Returns:
            True if deleted, False if not found
        """
        slug = restaurant_slug or ImageService.RESTAURANT_SLUG
        if ImageService.SUPABASE_STORAGE_ENABLED and SupabaseStorage.is_available():
            config = load_config(os.getenv("APP_NAME", "pronto"))
            bucket = resolve_bucket(category, config)
            storage_path = f"{slug}/{category}/{secure_filename(filename)}"
            return SupabaseStorage.delete_file(bucket, storage_path)

        upload_folder = Path(ImageService.UPLOAD_FOLDER)
        file_path = upload_folder / slug / category / secure_filename(filename)

        if file_path.exists() and file_path.is_file():
            file_path.unlink()
            return True

        return False

    @staticmethod
    def get_image_url(
        filename: str, category: str = "menu", restaurant_slug: str | None = None
    ) -> str:
        """Get the URL for an image."""
        slug = restaurant_slug or ImageService.RESTAURANT_SLUG
        if ImageService.SUPABASE_STORAGE_ENABLED and SupabaseStorage.is_available():
            config = load_config(os.getenv("APP_NAME", "pronto"))
            bucket = resolve_bucket(category, config)
            storage_path = f"{slug}/{category}/{filename}"
            return SupabaseStorage.get_public_url(bucket, storage_path)

        return f"/assets/{slug}/{category}/{filename}"


def save_uploaded_image(file: FileStorage, category: str = "menu") -> dict[str, str]:
    """Convenience function to save an uploaded image."""
    return ImageService.save_uploaded_image(file, category)


def list_images(category: str = "menu") -> list[dict[str, str]]:
    """Convenience function to list images."""
    return ImageService.list_images(category)


def delete_image(filename: str, category: str = "menu") -> bool:
    """Convenience function to delete an image."""
    return ImageService.delete_image(filename, category)
